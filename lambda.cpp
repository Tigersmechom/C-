int main() {
  int z;
  auto f = [z](int x, int y) {return x < y; };
  auto ff = f;
  f = ff; // только если пустой список захвата
  std::cout << typeid(f).name() << " " << sizeof(f);
}

// -------------------------------------------------------------------------

struct S {
  int a = 1;

  void foo() {
    auto f = [a](int x) {std::cout << a; return x; };
  }
};

// CE, потому что нельзя захватывать не локальные переменные (те, что не в одних полях (в данном случае не в полях функции foo))

// -------------------------------------------------------------------------

int main() {
  auto f = []<typename T>(T a) {
    std::cout << a;
  };
}

// -------------------------------------------------------------------------

template<typename... elems>
auto foo(elems... e) {
  return [e...](){(std::cout << ... << e) << '\n';};
}

int main() {
  auto it = foo(1, 2, 3.1);
  it();
  it();
}

// -------------------------------------------------------------------------

struct S {
  int x = 5;
  auto foo() {
    auto f = [=](){std::cout << x; };
    return f;
  }
};

int main() {
  S s;
  auto f = s.foo(); // OK
  f();
}

int main() {
  S* s = new S();
  auto f = s->foo(); // UB
  delete s;
  f();
}

/*
В данном случае захват по = это то же самое что и захват по &
Потому что =(deprecated) и неявно превратился в this (если что, & это то же самое что и this)
Но если сделать *this, то создастся константная копия

auto f = [x = x](){std::cout << x; }; // так тоже OK, const int
*/

// -------------------------------------------------------------------------

int main() {
  static int x = 0;
  auto f = [=]() mutable {
    ++x;
  };
  f();
  std::cout << x;// 1
}

/*
Статические/глобальные переменные нельзя захватывать!!!
Они все общие
*/

auto fun(int x) {
  static int a = 0;
  return [=](int y) {
    static int b = 0;
    a += x; b += y; // const int x - в полях
    return a + b;
  };
}

int main() {
  auto func1 = fun(1);
  auto func2 = fun(2);
  std::cout << func1(20) << ' ' << func1(30) << ' ' << func2(20) << ' ' << func2(30); // 21 52 74 106
}

// -------------------------------------------------------------------------

int main() {
  auto f = [](int x, int y) {return x + y;};
}

// При компиляции в классе lambda будет using ... = int(*)(int, int)
// И появится каст к этому
// Но если в списке захвата [x] добавится переменная, то его не будет

// -------------------------------------------------------------------------

// mutable просто у operator() убирает const
// Если делаю захват по = или &, то неиспользуемые объекты не будут в класс добавлены
int main() {
  int d = 3;
  auto f = [&](int x, int y) {return x + y;};
  std::cout << sizeof(f); // 1
}

// -------------------------------------------------------------------------

int main() {
  auto it = +[](int x) {return x;}; // Тип этого - int(*)(int)   (при этом в список захвата ничего клась нельзя)
}

// -------------------------------------------------------------------------